# קבצים בסיסיים
מערכת הקבצים היא הלב של מערכת יוניקס. מעבר לכל הקבצים הרגילים שאנחנו עובדים איתם, יש גם תיקיות כמו `/proc` או `/dev` שהן וירטואליות ובעצם נותנות ללינוקס לייצג מבנים מורכבים בלי להמציא דרכים חדשות לתקשר עם הקרנל. למשל, תנסו לקרוא את `/proc/self/status`, שהוא ”קובץ“ שכתובים בו כל הפרטים על התהליך הנוכחי. בגלל שהכל בלינוקס מתרכז סביב מערכת הקבצים, הקרנל יכול להציע המון פיצ'רים באופן ברור ומוכר.

כל קובץ על הדיסק שומר את המאפיינים הבאים (שאפשר לקרוא בעצמנו עם הפקודה `stat` בטרמינל):

* איזה user מחזיק בעלות על הקובץ (לפי מספר הuser)
* איזה group מחזיק בעלות על הקובץ (לפי מספר הgroup)
* מי יכול לגשת לקובץ, בביטים בסדר הבא (שנקראים גם file access mode):
	* set-user-id, set-group-id (שאיתם מממשים פקודות כמו סודו אבל זה ל לא ממש רלוונטי)
	* sticky bit (גם לא ממש רלוונטי, בעיקר שימושי לתיקיות)
	* user read, user write, user execute (האם מותר לבעלים של הקובץ לקרוא לכתוב ולהריץ)
	* group read, group write, group execute
	* all read, all write, all execute
* מתי בפעם האחרונה קראו את הקובץ, ערכו את הקובץ, שינו את המאפיינים שלו, ומתי יצרו את הקובץ
* האם הקובץ רגיל או שזה קובץ וירטואלי מכל מני סוגים

בכל תוכנה בלינוקס ולכל קובץ פתוח יש מספר שנקרא file descriptor. משתמשים ב-file descriptor כדי לפנות לקובץ פתוח מסוים. את ה-file descriptorים מקבלים מסיסקולים כמו open, מעבירים לסיסקולים כמו read ו-write ולבסוף סוגרים עם close.

**הערה מעניינת:** המספרים של ה-file descriptorים הם צפופים: בכל פעם שלינוקס יוצר file descriptor חדש, מובטח לנו שהוא יהיה המספר הכי נמוך שפנוי כרגע.

בדרך כלל לתוכנה יש את ה-file descriptorים הבאים כשהיא מתחילה לרוץ: 0 הוא הקלט של התוכנה (ובעיקר עושים ממנו read), 1 הוא הפלט של התוכנה (ועושים אליו write), ו-2 הוא השגיאות של התוכנה (וגם אליו עושים write). הסיבה להפרדה בין 1 ל-2 היא שלפעמים מתעלמים מהפלט הרגיל אבל עדיין רוצים לראות שגיאות.