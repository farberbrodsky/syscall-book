# דוגמה של pipe, fork ו-execve
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    if (pipe2(pipefd, O_CLOEXEC) == -1) { perror("couldn't create pipe"); return 1; }
    // we use O_CLOEXEC because it's easier than worrying about this ourselves in each fork

    char *ls_argv[] = { "/bin/ls", NULL };
    pid_t ls_pid = fork();
    if (ls_pid == 0) {
        if (dup2(pipefd[1], 1) == -1) _exit(1);  // fd 1 should be write end
        if (execve("/bin/ls", ls_argv, environ) == -1) _exit(1);
        // environ is a global from unistd.h with _GNU_SOURCE
    } else if (ls_pid == -1) {
        perror("couldn't fork");
        return 1;
    }
    close(pipefd[1]);  // don't need write end
    // if we don't close this in parent, grep won't know the pipe got closed

    char *grep_argv[] = { "/bin/grep", "hello", NULL };
    pid_t grep_pid = fork();
    if (grep_pid == 0) {
        if (dup2(pipefd[0], 0) == -1) _exit(1);  // fd 0 should be read end
        if (execve("/bin/grep", grep_argv, environ) == -1) _exit(1);
    } else if (grep_pid == -1) {
        perror("couldn't fork");
        return 1;
    }
    close(pipefd[0]);  // don't need read end

    // wait for both to finish
    pid_t waitpid_res;
    int wstatus;

    // wait even if there was an interrupt and while the return does not say it exited
    do waitpid_res = waitpid(ls_pid, &wstatus, 0);
    while ((waitpid_res == -1 && errno == EINTR) || !(WIFEXITED(wstatus) || WIFSIGNALED(wstatus)));
    if (waitpid_res == -1 && errno != EINTR) { perror("waitpid"); return 1; }

    // same for grep
    do waitpid_res = waitpid(grep_pid, &wstatus, 0);
    while ((waitpid_res == -1 && errno == EINTR) || !(WIFEXITED(wstatus) || WIFSIGNALED(wstatus)));
    if (waitpid_res == -1 && errno != EINTR) { perror("waitpid"); return 1; }

    return 0;
}
```

**תרגיל לקורא:** לקרוא את מה שיוצא מ-pipe לתוך משתנה.
<details><summary>רמז</summary>
צריך עוד pipe ש-grep יכתוב אליו ואז אפשר לקרוא מה-pipe הזה.
</details>

# TODO אני צריך לכתוב על waitpid!!!